---
layout: post
title: "Oneul Code - 15. Compilation vs. Interpretation, and the Current State of JavaScript"
date: 2025-10-22 17:30:00 +0900
categories: dev
---

# 1. 자바스크립트의 분류와 진화

### 전통적인 관점: 스크립트 언어 (인터프리터 언어)

초기의 **자바스크립트(JavaScript)**는 웹 페이지에 간단한 동작을 추가하기 위한 **스크립트 언어**로 설계되었습니다.

즉, **코드를 한 줄씩 해석하고 즉시 실행하는 방식(인터프리터)** 으로 동작했습니다.

이 방식은 수정 → 새로고침 → 실행이 가능한 높은 **유연성**을 제공했지만,
대규모 웹 애플리케이션에서는 **성능의 한계**가 있었습니다.

### 현대적 관점: JIT 기반의 하이브리드 언어

웹의 복잡도가 높아지고 성능 요구가 증가하면서, 자바스크립트 엔진들은 단순 인터프리터에서 벗어나 **JIT(Just-In-Time) 컴파일** 방식을 채택하게 됩니다.

JIT 컴파일 방식은 실행 도중 필요한 코드 부분만 즉석에서 기계어로 변환해 캐싱 및 재활용하는 기술로, 이를 통해 인터프리터의 유연함은 유지하면서도 컴파일 언어 수준으로 성능이 향상 되었습니다.

**성능 개선 수치:**

- V8 엔진의 JIT 컴파일러는 순수 인터프리터 대비 **약 100배 이상** 빠른 실행 속도를 제공합니다.
- 반복 실행되는 "핫 코드(Hot Code)"는 최적화를 통해 **C/C++ 수준**에 근접한 성능을 냅니다.

**결론:**
자바스크립트는 "스크립트 언어의 유연성"과 "컴파일 언어의 성능"을 결합한
하이브리드(Hybrid) 형태의 언어로 진화했습니다.

---

## 2. JIT 컴파일과 스코프 분석의 관계

### JIT(Just-In-Time) 컴파일이란?

JIT는 **코드를 실행하는 순간**, 필요한 부분만 **기계어로 변환**하여 최적화하는 기술입니다.
즉, "실행 시점에 이루어지는 컴파일"이라고 볼 수 있습니다.

**JIT 최적화 예시:**

```javascript
// 이 함수가 반복 호출되면 JIT이 기계어로 최적화합니다
function calculateTotal(price, quantity) {
  return price * quantity;
}

// 처음 몇 번은 인터프리터로 실행
calculateTotal(100, 5); // 인터프리터
calculateTotal(200, 3); // 인터프리터
calculateTotal(150, 2); // 인터프리터

// "핫 코드"로 감지되면 JIT이 기계어로 컴파일
for (let i = 0; i < 10000; i++) {
  calculateTotal(100, i); // JIT 최적화된 기계어로 실행 (매우 빠름)
}
```

**핫 코드란?**

프로그램 실행 시간 중 가장 많은 시간을 소비하거나 가장 빈번하게 호출되는 함수나 루프(반복문) 내부의 코드를 말합니다.

감지: JS 엔진은 코드가 실행될 때 각 함수의 호출 횟수와 실행 시간을 **측정(Profiling)**합니다.
이 측정 결과, 특정 임계값(Threshold)을 넘어선 코드 영역을 '뜨거운(Hot)' 영역으로 분류합니다.

### 그렇다면 스코프 분석은 언제 이루어질까?

JS 엔진은 코드를 실행하기 전,
**파싱(parsing)** → **컴파일(compile)** 단계에서
**렉시컬 스코핑(Lexical Scoping)** 규칙에 따라
변수와 함수의 **스코프(Scope)** 구조를 미리 확정합니다.

이때 만들어진 스코프 구조는 런타임 조건(if, for 등)에 영향을 받지 않습니다.
즉, **스코프는 실행 전 고정**되며, 실행 중 바뀌지 않습니다.

**렉시컬 스코핑이란?**

- 프로그래밍 언어, 특히 자바스크립트(JavaScript)에서 **변수의 유효 범위(Scope)**를 결정하는 핵심 규칙

- **"코드를 어디에 작성했는지"**에 따라 변수의 스코프가 정적으로 결정된다는 것

**스코프가 실행 전 결정되는 예시:**

```javascript
function outer() {
  const x = 10; // outer 함수 스코프

  function inner() {
    // 이 시점에 x 참조가 이미 결정됨 (렉시컬 스코핑)
    console.log(x); // 10 출력
  }

  return inner;
}

const myFunc = outer();
myFunc(); // x는 outer의 스코프에서 찾음 (실행 전 이미 결정됨)

// 런타임에 x가 변경되어도 스코프 구조는 불변
```

**핵심 요약**

- 스코프 분석은 **컴파일 단계**에서 확정된다. (코드 작성 시점의 위치로 결정)

- JIT은 **실행 시점**에 최적화 코드를 생성한다. (자주 쓰는 코드를 기계어로 변환)

→ 서로 다른 시점의 작업이지만, **결합되어 성능과 안정성을 동시에 확보**한다.

---

## 3. JIT 기술의 개발 주체

JIT 기술의 뿌리는 1960년대 **Lisp** 언어에서 유래한 일반적인 컴파일 최적화 기법입니다.  
자바스크립트 엔진들은 이를 현대적으로 발전시켜 각자 고유의 형태로 구현하고 있습니다.

| 브라우저         | JS 엔진            | JIT 기술 예시      |
| ---------------- | ------------------ | ------------------ |
| Chrome / Node.js | **V8**             | TurboFan, Ignition |
| Firefox          | **SpiderMonkey**   | IonMonkey          |
| Safari           | **JavaScriptCore** | FTL JIT            |

- 각 브라우저 개발사들은 성능 경쟁에서 앞서기 위해 엔진별로 독자적인 JIT 구조와 최적화 방식을 개발했습니다.

---

## 4. 코드 컴파일레이션(Code Compilation)이란?

**컴파일레이션**이란 프로그래머가 작성한 **고급 언어 코드**를  
컴퓨터의 CPU가 이해할 수 있는 **기계어 코드**로 변환하는 과정입니다.

이 과정은 프로그램이 실행되기 전에 **전체 소스를 미리 번역**하는 것이 특징입니다.

예:

- C, C++, Go, Rust, Java(바이트코드 컴파일)

```text
Source Code (고급 언어)
   ↓
Compiler
   ↓
Machine Code (기계어)
   ↓
CPU 실행
```

---

## 5. 인터프리터(Interpretation)란?

**인터프리터(Interpretation)**는
**코드를 한 줄씩 읽으면서 즉시 변환 + 실행**하는 방식입니다.
즉, "번역과 실행이 동시에 일어나는" 구조입니다.

별도의 실행 파일을 생성하지 않고,
**인터프리터 프로그램이 직접 코드 실행**을 담당합니다.

예:

- JavaScript, Python, Ruby, PHP

```text
Source Code
   ↓ (한 줄씩)
Interpreter
   ↓ (즉시 변환 및 실행)
CPU 실행
```

---

## 6. 컴파일 vs 인터프리터

| 구분                      | 컴파일 (Compilation)                          | 인터프리터 (Interpretation)                          |
| ------------------------- | --------------------------------------------- | ---------------------------------------------------- |
| **변환 시점**             | 실행 전                                       | 실행 중 (동시)                                       |
| **실행 방식**             | 전체 코드를 미리 기계어로 변환 후 실행        | 코드 한 줄씩 실시간 변환 및 실행                     |
| **변환 & 실행 분리 여부** | 변환과 실행이 완전히 분리                     | 변환과 실행이 동시에 수행                            |
| **결과물**                | 독립적인 실행 파일 생성                       | 별도의 실행 파일 없음                                |
| **실행 속도**             | 빠름 (기계어 수준, ~10ns)                     | 상대적으로 느림 (~1000ns)                            |
| **하드웨어 의존성**       | 특정 CPU 아키텍처에 맞게 최적화 → 이식성 낮음 | 인터프리터만 있으면 어디서든 실행 가능 → 이식성 높음 |
| **오류 발견**             | 컴파일 단계에서 발견                          | 실행 중 발견                                         |
| **대표 언어**             | C, C++, Java                                  | JS, Python, Ruby                                     |
| **비유로 이해하기**       | _책을 미리 번역해둔 뒤 읽기_                  | _책을 읽으면서 동시에 통역하기_                      |

**속도 차이:**

- C/C++ 컴파일 코드: 단순 연산 약 1-10 나노초
- Python 인터프리터: 같은 연산 약 100-1000 나노초
- JavaScript (JIT 적용): 약 10-100 나노초 (컴파일 언어에 근접)

---

## 7. Oneul Code를 정리하며...

### 결론:

현대의 **자바스크립트(JavaScript)** 는 단순한 스크립트 언어가 아닙니다.  
**JIT 컴파일러**를 통해 실행 중 필요한 부분만 컴파일하고,  
**스코프 분석 + 코드 최적화 + 캐싱**까지 동시에 수행합니다.

정리하자면, **자바스크립트는 인터프리터처럼 유연하지만, 컴파일 언어처럼 빠르게 동작하는 하이브리드 실행 모델 (Hybrid Execution Model)을 가진 언어입니다.**

Oneul Code는 오늘 배운 내용을 정리하며,  
자바스크립트라는 하이브리드 실행 모델을 이해하는 것은 현대 프론트엔드 개발자에게 필수적인 역량입니다.
변수가 접근되는 방식을 예측하여 클로저 메모리 최적화를 달성하고, JIT가 좋아하는 타입 안정적인 코드를 작성함으로써,
우리는 단순히 코드를 동작시키는 것을 넘어 사용자 체감 성능을 극대화하는 개발자가 될 수 있습니다.
